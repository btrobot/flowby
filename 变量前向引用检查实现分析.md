# Flowby DSL 变量前向引用检查实现分析

## 一、当前机制分析

### 1.1 现有符号表机制

**Parser 中已有符号表（symbol_table_stack）**：
- 位置：`src/flowby/parser.py:89`
- 类型：`SymbolTableStack`
- 作用域管理：支持嵌套作用域（step, for, function）

**已注册变量的时机**：
```python
# let/const 声明时注册（parser.py:1651）
def _parse_let_statement(self) -> LetStatement:
    # ... 解析 ...
    
    # 注册到符号表
    self.symbol_table_stack.define(
        name=name_token.value,
        value=None,  # 值在运行时计算
        symbol_type=SymbolType.VARIABLE,
        line_number=line
    )
```

**已有的 VR 规则检查**：
- VR-VAR-003: 变量重复声明检查（parser.py:1637）
- VR-VAR-004: 常量修改检查（parser.py:1699）

### 1.2 当前变量引用处理

**解析阶段（Parser）**：
```python
# parser.py:2579 - 解析 Identifier，不做任何检查
if self._match(TokenType.IDENTIFIER):
    name = self._previous().value
    return Identifier(name=name, line=line)  # ← 直接返回，无检查
```

**运行时阶段（ExpressionEvaluator）**：
```python
# expression_evaluator.py:146 - 运行时查找
def _eval_identifier(self, expr: Identifier) -> Any:
    # 1. 检查内置命名空间
    if expr.name in BUILTIN_NAMESPACES:
        return BUILTIN_NAMESPACES[expr.name]
    
    # 2. 检查内置函数
    if expr.name in BUILTIN_FUNCTIONS:
        return BUILTIN_FUNCTIONS[expr.name]
    
    # 3. 检查系统命名空间
    if expr.name in SYSTEM_NAMESPACES:
        return SystemNamespaceProxy(expr.name, self.system_variables)
    
    # 4. 查找用户变量（这里才报错）
    try:
        return self.symbol_table.get(expr.name, expr.line)
    except Exception:
        raise ExecutionError(message=f"变量 '{expr.name}' 未定义")
```

---

## 二、实现方案设计

### 2.1 方案选择：Parser 阶段检查 vs 运行时检查

| 对比项 | Parser 阶段 | 运行时阶段 |
|--------|------------|-----------|
| **检查时机** | 解析时（早期） | 执行时（延迟） |
| **错误发现** | ✅ 立即发现 | ❌ 运行到才发现 |
| **实现复杂度** | ⚠️ 中等 | ✅ 简单 |
| **性能影响** | ✅ 无 | ⚠️ 每次求值检查 |
| **架构一致性** | ✅ 符合 VR 规则机制 | ⚠️ 需修改多处 |

**推荐方案**：**Parser 阶段检查**（VR-001 规则）

**理由**：
1. ✅ 早期发现错误，用户体验更好
2. ✅ 与现有 VR 规则机制一致
3. ✅ Parser 已有 symbol_table_stack，基础设施完备
4. ✅ 性能更优（解析一次 vs 每次运行检查）

---

### 2.2 具体实现方案

#### **核心思路**：在解析 Identifier 时检查符号表

#### **修改位置：`src/flowby/parser.py:2579`**

```python
def _parse_primary(self) -> Expression:
    """解析基础表达式"""
    line = self._peek().line
    
    # ... 其他表达式解析 ...
    
    # 标识符 (变量引用) - 新增 VR-001 检查
    if self._match(TokenType.IDENTIFIER):
        name = self._previous().value
        line = self._previous().line
        
        # ============ 新增：VR-001 变量未定义检查 ============
        self._check_variable_defined(name, line)
        # ===================================================
        
        return Identifier(name=name, line=line)
```

#### **新增检查方法**：

```python
def _check_variable_defined(self, name: str, line: int) -> None:
    """
    VR-001: 检查变量是否已定义
    
    排除：
    1. 内置命名空间（Math, Date, JSON 等）
    2. 内置函数（len, str, int 等）
    3. 系统命名空间（page, env, context 等）
    4. 循环变量（for 语句中声明的变量，在解析循环体时自动注册）
    
    Args:
        name: 变量名
        line: 引用行号
    """
    # 1. 排除内置命名空间
    from .builtin_functions import BUILTIN_NAMESPACES, BUILTIN_FUNCTIONS
    if name in BUILTIN_NAMESPACES or name in BUILTIN_FUNCTIONS:
        return
    
    # 2. 排除系统命名空间
    from .system_namespaces import SYSTEM_NAMESPACES
    if name in SYSTEM_NAMESPACES:
        return
    
    # 3. 检查符号表
    if not self.symbol_table_stack.exists(name):
        # 记录 VR-001 违规
        self.violations.append(Violation(
            rule_id="VR-001",
            message=f"变量 '{name}' 未定义（使用前必须先用 let 或 const 声明）",
            line_number=line,
            severity="ERROR"
        ))
```

---

## 三、需要修改的代码位置

### 3.1 核心修改（必须）

| 文件 | 位置 | 修改内容 | 难度 |
|------|------|---------|------|
| `parser.py` | 2579 | 在 `_parse_primary()` 中解析 Identifier 时调用检查 | ⭐ 简单 |
| `parser.py` | +新增 | 添加 `_check_variable_defined()` 方法 | ⭐ 简单 |
| `parser.py` | 1750-1789 | for 循环变量自动注册（已有，可能需微调） | ⭐ 简单 |

### 3.2 特殊场景处理（需考虑）

#### **场景 1：for 循环变量**

```python
# 当前实现（parser.py:1759）
for item in items:
    log item  # item 在循环体内自动可用

# 处理方式：for 循环解析时，在进入循环体前注册循环变量
self.symbol_table_stack.enter_scope("for_loop")
# ← 这里需要注册 item 变量
for var_name in variable_names:
    self.symbol_table_stack.define(
        name=var_name,
        value=None,
        symbol_type=SymbolType.VARIABLE,
        line_number=line
    )
```

**评估**：需要修改 `_parse_for_each_loop()` 方法

#### **场景 2：函数参数**

```python
function add(a, b):
    return a + b  # a, b 在函数体内自动可用

# 处理方式：解析函数体前注册参数
for param in params:
    self.symbol_table_stack.define(
        name=param,
        value=None,
        symbol_type=SymbolType.VARIABLE,
        line_number=line
    )
```

**评估**：需要修改 `_parse_function_def()` 方法

#### **场景 3：import 导入的符号**

```python
import {greet} from "utils"
let message = greet("Alice")  # greet 需要在符号表中

# 处理方式：解析 import 时注册导入的符号
for symbol_name in node.symbols:
    self.symbol_table_stack.define(
        name=symbol_name,
        value=None,
        symbol_type=SymbolType.IMPORTED,  # 新增类型
        line_number=line
    )
```

**评估**：需要修改 `_parse_import_statement()` 方法

#### **场景 4：库导出符号（library 模式）**

```python
# lib/utils.flow
library utils
export greet  # greet 在 export 前必须已定义

# 处理方式：export 时检查符号是否存在
if not self.symbol_table_stack.exists(name):
    self.violations.append(Violation(...))
```

**评估**：需要修改 `_parse_export_statement()` 方法

---

### 3.3 完整修改清单

| 序号 | 文件 | 方法 | 修改内容 | 难度 | 工作量 |
|------|------|------|---------|------|--------|
| 1 | `parser.py` | `_parse_primary()` | 添加 `_check_variable_defined()` 调用 | ⭐ | 5 分钟 |
| 2 | `parser.py` | 新增 | 实现 `_check_variable_defined()` 方法 | ⭐ | 15 分钟 |
| 3 | `parser.py` | `_parse_for_each_loop()` | 循环变量提前注册到符号表 | ⭐⭐ | 20 分钟 |
| 4 | `parser.py` | `_parse_function_def()` | 函数参数提前注册到符号表 | ⭐⭐ | 20 分钟 |
| 5 | `parser.py` | `_parse_import_statement()` | 导入符号注册到符号表 | ⭐⭐ | 15 分钟 |
| 6 | `parser.py` | `_parse_export_statement()` | 检查导出符号是否已定义 | ⭐ | 10 分钟 |
| 7 | `symbol_table.py` | `SymbolType` | 新增 `IMPORTED` 类型（可选） | ⭐ | 5 分钟 |

**总工作量**：约 **1.5 小时**

---

## 四、影响面分析

### 4.1 代码变更范围

#### **直接影响**：
- ✅ `parser.py`：约 100 行新增/修改
- ✅ `symbol_table.py`：约 10 行（新增 IMPORTED 类型）
- ✅ `grammar/MASTER.md`：更新 VR-001 规则说明

#### **间接影响**：
- ⚠️ 测试用例：需修改所有使用未定义变量的测试
- ⚠️ 示例脚本：需修改 `examples/` 中的脚本
- ⚠️ 文档：更新 ARCHITECTURE.md、README.md

---

### 4.2 测试影响分析

#### **测试统计**：
```
总测试文件: 15 个（grammar_alignment）
总测试用例: 1082 个
v3.0+ 测试: ~900 个
```

#### **可能失败的测试类型**：

1. **使用未定义变量的测试**（预计 0-5 个）
   ```python
   # 示例：错误用法测试
   def test_undefined_variable():
       source = "log x"  # x 未定义
       # 现在会在 Parser 阶段报错
   ```

2. **测试框架内部使用的变量**（预计 10-20 个）
   ```python
   # 可能的情况：测试代码本身有问题
   def test_something():
       source = """
       # 忘记定义变量
       log message
       """
   ```

3. **特殊场景测试**（预计 5-10 个）
   - for 循环变量测试
   - 函数参数测试
   - import 导入测试

#### **测试修复策略**：

**策略 1：修复测试代码**（推荐）
```python
# 修复前
source = "log x"

# 修复后
source = """
let x = 10
log x
"""
```

**策略 2：添加异常预期**
```python
# 测试 VR-001 违规
def test_undefined_variable_violation():
    source = "log x"
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 1
    assert violations[0].rule_id == "VR-001"
```

**预计测试修复工作量**：
- 修复失败测试：**2-4 小时**
- 添加新测试（VR-001 专项）：**1-2 小时**

---

### 4.3 兼容性影响

#### **向后兼容性**：❌ **破坏性变更**

| 影响项 | 影响程度 | 说明 |
|--------|---------|------|
| **现有脚本** | ⚠️ 高 | 使用未定义变量的脚本会报错 |
| **示例代码** | ⚠️ 中 | 需检查并修复 examples/ |
| **用户代码** | ⚠️ 高 | 可能大量现有脚本需修改 |
| **测试用例** | ⚠️ 中 | 部分测试需修改 |

#### **迁移策略**：

**方案 1：渐进式引入（推荐）**
```python
# 添加配置选项
class ParserConfig:
    strict_mode: bool = False  # 默认关闭
    check_undefined_variables: bool = False  # 默认关闭

# v6.1: 默认关闭，警告模式
# v6.2: 默认开启，错误模式
# v7.0: 强制开启
```

**方案 2：警告模式**
```python
# 先记录为 WARNING 而非 ERROR
self.violations.append(Violation(
    rule_id="VR-001",
    message=f"变量 '{name}' 未定义",
    severity="WARNING"  # ← 先警告
))
```

**方案 3：显式启用**
```python
# 通过注释或配置启用
# flowby: strict-mode

let x = 10
log x
```

---

### 4.4 性能影响

#### **解析性能**：
- 新增检查：每个 Identifier 调用一次 `exists()`
- 符号表查找：O(1) 到 O(n)（n 为作用域深度，通常 < 5）
- **预计影响**：< 5% 解析时间增加

#### **运行时性能**：
- 无影响（检查在 Parser 阶段）

#### **内存影响**：
- 符号表占用：每个变量 ~100 bytes
- 违规记录：每个违规 ~200 bytes
- **预计影响**：< 1MB 增加（典型脚本）

---

## 五、实现难度评估

### 5.1 技术难度

| 维度 | 难度 | 说明 |
|------|------|------|
| **核心逻辑** | ⭐⭐ 简单 | 主要是调用现有 API |
| **特殊场景** | ⭐⭐⭐ 中等 | for/函数参数/import 需仔细处理 |
| **测试适配** | ⭐⭐⭐ 中等 | 需修改和新增测试 |
| **文档更新** | ⭐⭐ 简单 | 更新规范和说明 |

**总体评估**：⭐⭐⭐ **中等难度**

---

### 5.2 工作量估算

| 阶段 | 任务 | 时间 |
|------|------|------|
| **开发** | 核心逻辑实现 | 1.5 小时 |
| **开发** | 特殊场景处理 | 1.5 小时 |
| **测试** | 修复失败测试 | 2-4 小时 |
| **测试** | 添加新测试 | 1-2 小时 |
| **文档** | 更新文档 | 1 小时 |
| **Code Review** | 代码审查 | 1 小时 |

**总计**：**8-11 小时**（1-1.5 工作日）

---

### 5.3 风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| **测试大量失败** | 中 | 高 | 先运行测试，评估影响范围 |
| **特殊场景遗漏** | 中 | 中 | 全面梳理所有变量引用场景 |
| **用户代码破坏** | 高 | 高 | 采用渐进式引入策略 |
| **性能下降** | 低 | 低 | 符号表查找已优化 |

---

## 六、实施建议

### 6.1 推荐实施路径

**阶段 1：最小化实现（MVP）**
- ✅ 仅实现核心逻辑（`_check_variable_defined()`）
- ✅ 处理基本场景（let/const 变量）
- ✅ 暂不处理特殊场景（for/函数/import）
- ✅ 测试影响评估

**时间**：2-3 小时

---

**阶段 2：完整实现**
- ✅ 处理所有特殊场景
- ✅ 修复所有失败测试
- ✅ 添加专项测试

**时间**：6-8 小时

---

**阶段 3：渐进式部署**
- ✅ 默认警告模式（v6.1）
- ✅ 默认错误模式（v6.2）
- ✅ 强制启用（v7.0）

**时间**：跨版本迭代

---

### 6.2 可选优化

**优化 1：缓存内置名称检查**
```python
# 避免每次都查询
_BUILTIN_NAMES = set(BUILTIN_NAMESPACES.keys()) | \
                 set(BUILTIN_FUNCTIONS.keys()) | \
                 set(SYSTEM_NAMESPACES)

def _check_variable_defined(self, name: str, line: int):
    if name in self._BUILTIN_NAMES:
        return
    # ...
```

**优化 2：批量检查**
```python
# 收集所有 Identifier，最后统一检查
self._pending_identifiers.append((name, line))

def _finalize_scope(self):
    for name, line in self._pending_identifiers:
        self._check_variable_defined(name, line)
    self._pending_identifiers.clear()
```

---

## 七、代码示例

### 7.1 完整实现示例

```python
# ============ src/flowby/parser.py ============

class Parser:
    def __init__(self):
        # ... 现有代码 ...
        self._builtin_names = None  # 缓存内置名称
    
    def _get_builtin_names(self) -> set:
        """获取所有内置名称（缓存）"""
        if self._builtin_names is None:
            from .builtin_functions import BUILTIN_NAMESPACES, BUILTIN_FUNCTIONS
            from .system_namespaces import SYSTEM_NAMESPACES
            
            self._builtin_names = (
                set(BUILTIN_NAMESPACES.keys()) |
                set(BUILTIN_FUNCTIONS.keys()) |
                set(SYSTEM_NAMESPACES)
            )
        return self._builtin_names
    
    def _check_variable_defined(self, name: str, line: int) -> None:
        """
        VR-001: 检查变量是否已定义
        
        排除内置名称，只检查用户定义的变量。
        """
        # 1. 排除内置名称
        if name in self._get_builtin_names():
            return
        
        # 2. 检查符号表
        if not self.symbol_table_stack.exists(name):
            self.violations.append(Violation(
                rule_id="VR-001",
                message=(
                    f"变量 '{name}' 未定义\n"
                    f"提示：变量使用前必须先用 'let' 或 'const' 声明"
                ),
                line_number=line,
                severity="ERROR"
            ))
    
    def _parse_primary(self) -> Expression:
        """解析基础表达式"""
        line = self._peek().line
        
        # ... 其他表达式 ...
        
        # 标识符 (变量引用)
        if self._match(TokenType.IDENTIFIER):
            name = self._previous().value
            line = self._previous().line
            
            # VR-001: 检查变量是否已定义
            self._check_variable_defined(name, line)
            
            return Identifier(name=name, line=line)
        
        # ...
    
    def _parse_for_each_loop(self) -> EachLoop:
        """解析 for 循环（提前注册循环变量）"""
        # ... 解析循环头 ...
        
        # 创建循环作用域
        self.symbol_table_stack.enter_scope("for_loop")
        
        try:
            # 提前注册循环变量（VR-001 所需）
            for var_name in variable_names:
                self.symbol_table_stack.define(
                    name=var_name,
                    value=None,
                    symbol_type=SymbolType.VARIABLE,
                    line_number=line
                )
            
            # 解析循环体
            # ...
        finally:
            self.symbol_table_stack.exit_scope()
    
    def _parse_function_def(self) -> FunctionDefNode:
        """解析函数定义（提前注册参数）"""
        # ... 解析函数头 ...
        
        # 创建函数作用域（注意：当前实现可能未创建，需确认）
        # self.symbol_table_stack.enter_scope(f"function_{func_name}")
        
        # 提前注册函数参数（VR-001 所需）
        for param in params:
            self.symbol_table_stack.define(
                name=param,
                value=None,
                symbol_type=SymbolType.VARIABLE,
                line_number=line
            )
        
        # 解析函数体
        # ...
```

---

### 7.2 测试用例示例

```python
# ============ tests/test_vr_001_undefined_variable.py ============

import pytest
from flowby.lexer import Lexer
from flowby.parser import Parser

def test_vr001_undefined_variable_basic():
    """测试基本的未定义变量检查"""
    source = """
log x
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 1
    assert violations[0].rule_id == "VR-001"
    assert "x" in violations[0].message
    assert "未定义" in violations[0].message

def test_vr001_defined_variable_ok():
    """测试已定义变量不报错"""
    source = """
let x = 10
log x
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 0

def test_vr001_builtin_function_ok():
    """测试内置函数不报错"""
    source = """
log len([1, 2, 3])
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 0

def test_vr001_system_namespace_ok():
    """测试系统命名空间不报错"""
    source = """
log page.url
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 0

def test_vr001_for_loop_variable_ok():
    """测试 for 循环变量不报错"""
    source = """
for item in [1, 2, 3]:
    log item
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 0

def test_vr001_function_parameter_ok():
    """测试函数参数不报错"""
    source = """
function add(a, b):
    return a + b
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 0

def test_vr001_multiple_undefined():
    """测试多个未定义变量"""
    source = """
log x
log y
log z
    """
    tokens = Lexer().tokenize(source)
    parser = Parser()
    ast = parser.parse(tokens)
    
    violations = parser.get_violations()
    assert len(violations) == 3
    assert all(v.rule_id == "VR-001" for v in violations)
```

---

## 八、总结

### 8.1 关键结论

| 项目 | 评估 |
|------|------|
| **实现难度** | ⭐⭐⭐ 中等 |
| **工作量** | 8-11 小时（1-1.5 天） |
| **技术风险** | ⚠️ 中等（测试影响） |
| **用户影响** | ⚠️ 高（破坏性变更） |
| **价值收益** | ✅ 高（早期错误发现） |

---

### 8.2 核心要点

1. **技术可行性**：✅ 高
   - Parser 已有符号表基础设施
   - 只需添加检查逻辑，无需重构

2. **实现复杂度**：⚠️ 中等
   - 核心逻辑简单
   - 特殊场景需仔细处理（for/函数/import）

3. **测试影响**：⚠️ 中等
   - 预计 10-30 个测试需修改
   - 需添加 VR-001 专项测试

4. **兼容性**：❌ 破坏性
   - 需采用渐进式引入策略
   - 建议默认警告模式，逐步过渡

---

### 8.3 推荐行动

**立即可做**：
1. 实现 MVP（2-3 小时）
2. 评估测试影响（1 小时）
3. 决定引入策略（警告 vs 错误）

**短期规划**：
1. 完整实现（6-8 小时）
2. 修复所有测试（2-4 小时）
3. 更新文档（1 小时）

**长期规划**：
1. v6.1: 警告模式（默认关闭）
2. v6.2: 错误模式（默认开启）
3. v7.0: 强制启用

---

**报告生成时间**：2025-11-30
**Flowby 版本**：v0.1.0 (语法版本 v5.1)
