# Flowby DSL 前向引用分析报告

## 一、测试结果总结

### 1. 变量前向引用
```
测试代码：
log x
let x = 10

结果：[FAIL] Parser 没有检测到变量前向引用
```

### 2. 函数前向引用
```
测试代码：
let result = add(1, 2)
function add(a, b):
    return a + b

结果：[FAIL] 运行时错误 - 未定义的函数: 'add'
```

### 3. 函数后向引用（正常）
```
测试代码：
function add(a, b):
    return a + b
let result = add(1, 2)

结果：[PASS] 成功执行
```

### 4. 相互递归函数
```
测试代码：
function isEven(n):
    if n == 0:
        return True
    return isOdd(n - 1)

function isOdd(n):
    if n == 0:
        return False
    return isEven(n - 1)

结果：[FAIL] 不支持递归调用
```

---

## 二、核心发现

### ✅ 明确结论

| 引用类型 | 是否要求前向引用 | 检查阶段 | 备注 |
|---------|----------------|---------|------|
| **变量** | ❌ **不要求**（隐式） | 运行时 | Parser 不检查，运行时才报错 |
| **函数** | ✅ **要求**（隐式） | 运行时 | 必须先定义后调用 |
| **递归** | ✅ **禁止** | 运行时 | 包括自递归和相互递归 |

---

## 三、实现机制分析

### 1. 变量引用检查 - **运行时检查**

**Parser 阶段（src/flowby/parser.py:2579-2581）**：
```python
# 标识符 (变量引用)
if self._match(TokenType.IDENTIFIER):
    name = self._previous().value
    return Identifier(name=name, line=line)  # 不做任何检查
```

**运行时阶段（src/flowby/expression_evaluator.py:146-168）**：
```python
def _eval_identifier(self, expr: Identifier) -> Any:
    """求值标识符（查找变量、内置函数和命名空间）"""
    # 1. 检查内置命名空间
    if expr.name in BUILTIN_NAMESPACES:
        return BUILTIN_NAMESPACES[expr.name]
    
    # 2. 检查内置函数
    if expr.name in BUILTIN_FUNCTIONS:
        return BUILTIN_FUNCTIONS[expr.name]
    
    # 3. 检查系统命名空间
    if expr.name in SYSTEM_NAMESPACES:
        return SystemNamespaceProxy(expr.name, self.system_variables)
    
    # 4. 最后查找用户定义的变量（这里才检查是否定义）
    try:
        return self.symbol_table.get(expr.name, expr.line)
    except Exception as e:
        raise ExecutionError(  # 运行时才报错
            line=expr.line,
            statement=f"变量引用: {expr.name}",
            error_type=ExecutionError.VARIABLE_NOT_FOUND,
            message=f"变量 '{expr.name}' 未定义"
        )
```

**结论**：
- Parser **不检查**变量是否定义
- 只在运行时求值时检查
- 因此变量前向引用在 Parser 阶段不会报错

---

### 2. 函数引用检查 - **运行时检查 + 前向引用禁止**

**函数定义（src/flowby/interpreter.py:1509-1567）**：
```python
def _execute_function_def(self, statement: FunctionDefNode) -> None:
    """
    执行函数定义语句
    - 将函数注册到符号表中
    - 存储函数名、参数列表和函数体 AST
    - 函数体在调用时才执行（延迟执行）
    """
    func_name = statement.name
    params = statement.params
    body = statement.body
    
    # 创建函数符号并注册到符号表
    func_symbol = FunctionSymbol(
        name=func_name,
        params=params,
        body=body,
        closure_scope=self.symbol_table.current_scope()
    )
    
    self.symbol_table.define(
        name=func_name,
        value=func_symbol,
        symbol_type=SymbolType.FUNCTION,
        line_number=statement.line
    )
```

**函数调用（src/flowby/interpreter.py:1615-1665）**：
```python
def call_function(self, func_name: str, args: list, line: int) -> Any:
    """调用用户定义的函数"""
    # 1. 从符号表获取函数符号
    try:
        if not self.symbol_table.exists(func_name):
            raise KeyError(f"函数 '{func_name}' 未定义")
        
        # 查找符号
        current_table = self.symbol_table.current_scope()
        symbol = None
        while current_table and symbol is None:
            if func_name in current_table.symbols:
                symbol = current_table.symbols[func_name]
                break
            current_table = current_table.parent
        
        if symbol is None:
            raise KeyError(f"函数 '{func_name}' 未定义")
            
    except KeyError:
        raise ExecutionError(
            line=line,
            statement=f"{func_name}(...)",
            error_type=ExecutionError.RUNTIME_ERROR,
            message=f"未定义的函数: '{func_name}'"  # 运行时才报错
        )
```

**执行流程**：
```
1. Parser 阶段：
   - 解析到函数定义 → 创建 FunctionDefNode AST 节点
   - 解析到函数调用 → 创建 FunctionCall AST 节点
   - **不做任何检查**

2. Interpreter 执行阶段（按顺序执行语句）：
   - 遇到 FunctionDefNode → 注册到符号表
   - 遇到 LetStatement(add(1,2)) → 求值函数调用
       → 查找符号表中的 'add'
       → 如果此时 add 还没定义 → 报错：未定义的函数

3. 关键：顺序执行
   - 如果先定义后调用 → ✅ 成功
   - 如果先调用后定义 → ❌ 失败（函数还没注册到符号表）
```

**结论**：
- 函数必须**先定义后使用**
- 这是**隐式要求**（不是显式设计，而是顺序执行的自然结果）
- 不支持前向引用

---

### 3. 递归禁止机制

**检测递归调用（src/flowby/interpreter.py:1615-1720）**：
```python
def call_function(self, func_name: str, args: list, line: int) -> Any:
    # ... 获取函数符号 ...
    
    # 2. 检测递归调用（通过调用栈）
    if func_name in self._call_stack:
        raise ExecutionError(
            line=line,
            statement=f"{func_name}(...)",
            error_type=ExecutionError.RUNTIME_ERROR,
            message=f"不支持递归调用: 函数 '{func_name}' 正在执行中"
        )
    
    # 3. 进入调用栈
    self._call_stack.append(func_name)
    
    try:
        # ... 执行函数体 ...
        pass
    finally:
        # 4. 退出调用栈
        self._call_stack.pop()
```

**结论**：
- 明确禁止递归（包括自递归和相互递归）
- 通过调用栈检测
- 运行时报错

---

## 四、设计分析

### 1. 为什么 Parser 不做变量检查？

**可能原因**：
1. **简化 Parser 逻辑**：Parser 只负责语法分析，不负责语义分析
2. **支持动态特性**：某些语言特性可能需要运行时才能确定变量
3. **延迟检查**：将检查推迟到运行时，可以更灵活地处理作用域

**影响**：
- ❌ 无法在编译时发现变量未定义错误
- ❌ 运行到错误行才报错（浪费时间）
- ✅ 但实现简单，符合解释器架构

---

### 2. 为什么函数必须前向定义？

**根本原因**：
- **顺序执行模型**：Interpreter 按语句顺序执行
- **立即注册**：函数定义时立即注册到符号表
- **立即查找**：函数调用时立即查找符号表

**对比其他语言**：
```javascript
// JavaScript - 支持函数提升（hoisting）
console.log(add(1, 2));  // ✅ 可以
function add(a, b) { return a + b; }

// Python - 支持函数前向引用（运行时查找）
def foo():
    return bar()  # ✅ 可以，运行时才查找 bar

def bar():
    return 42
```

**Flowby 的选择**：
- ❌ 不支持函数提升（不是编译型语言）
- ❌ 不支持延迟查找（函数调用时立即查找）
- ✅ 简单直接：先定义后使用

---

### 3. 为什么禁止递归？

**文档说明**（ARCHITECTURE.md）：
```
function add(a, b):
    return a + b

特性:
- 定义用户自定义函数
- 函数具有独立的局部作用域
- 参数按值传递
- **不支持递归 (运行时检测)**  ← 明确说明
- ~~不支持闭包~~（v5.1 已支持）
```

**可能原因**：
1. **防止栈溢出**：递归可能导致无限循环
2. **简化实现**：递归需要更复杂的调用栈管理
3. **定位 DSL**：Web 自动化场景较少需要递归

---

## 五、与文档的一致性

### ARCHITECTURE.md 明确说明：

#### VR-001 规则（语义检查规则）
> **VR-001**: 变量使用前必须声明

**实际实现**：
- ✅ 运行时检查（ExpressionEvaluator._eval_identifier）
- ❌ Parser 阶段不检查

#### 函数定义特性
> 不支持递归 (运行时检测)

**实际实现**：
- ✅ 运行时通过调用栈检测
- ✅ 抛出 ExecutionError

#### 符号表规则
> Parser 和 Interpreter 共享 SymbolTable：
> - Parser 阶段：语义检查（VR 规则验证）
> - Interpreter 阶段：变量查找和作用域管理

**实际实现**：
- ⚠️ Parser 阶段似乎**不做 VR-001 检查**
- ✅ Interpreter 阶段做查找和作用域管理

---

## 六、总结与建议

### 当前状态

| 项目 | 前向引用要求 | 检查阶段 | 显式/隐式 |
|------|------------|---------|----------|
| 变量 | ❌ 不要求 | 运行时 | **隐式**（Parser 不检查） |
| 函数 | ✅ 要求 | 运行时 | **隐式**（顺序执行导致） |
| 递归 | ✅ 禁止 | 运行时 | **显式**（主动检测） |

### 关键结论

1. **没有显式的前向引用要求声明**
   - 语法规范中没有明确说明
   - 但**隐式地**，函数必须先定义后使用

2. **变量检查完全在运行时**
   - Parser 不做任何检查
   - 可能导致延迟发现错误

3. **函数前向引用禁止是副作用**
   - 不是设计意图，是顺序执行的结果
   - 如果要支持，需要两阶段解析：
     1. 第一阶段：收集所有函数定义
     2. 第二阶段：执行语句

4. **递归明确禁止**
   - 有明确的设计决策
   - 运行时检测并报错

### 可能的改进方向

**如果要支持函数前向引用**：
```python
def execute(self, program: Program) -> None:
    """两阶段执行"""
    # Phase 1: 预注册所有函数定义
    for stmt in program.body:
        if isinstance(stmt, FunctionDefNode):
            self._execute_function_def(stmt)
    
    # Phase 2: 执行所有语句
    for stmt in program.body:
        if not isinstance(stmt, FunctionDefNode):  # 跳过已处理的函数定义
            self._execute_statement(stmt)
```

**如果要在 Parser 阶段检查变量**：
```python
def _parse_primary(self) -> Expression:
    # 标识符 (变量引用)
    if self._match(TokenType.IDENTIFIER):
        name = self._previous().value
        line = self._previous().line
        
        # 新增：检查变量是否已定义
        if not self.symbol_table_stack.exists(name):
            # 记录 VR-001 违规
            self.violations.append(Violation(
                rule_id="VR-001",
                message=f"变量 '{name}' 未定义",
                line_number=line,
                severity="ERROR"
            ))
        
        return Identifier(name=name, line=line)
```

---

## 七、测试代码

完整测试代码见：`E:\cf\ads\flowby\test_forward_ref.py`

运行方式：
```bash
python test_forward_ref.py
```

测试覆盖：
- ✅ 变量前向引用
- ✅ 函数前向引用
- ✅ 函数后向引用
- ✅ 相互递归函数

---

**报告生成时间**: 2025-11-30
**Flowby 版本**: v0.1.0 (语法版本 v5.1)
