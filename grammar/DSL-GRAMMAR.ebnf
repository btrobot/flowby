(* ============================================================================= *)
(* Flowby DSL - EBNF Grammar Specification                                    *)
(* Version: 6.6                                                                *)
(* Generated: 2025-12-01                                                       *)
(* Branch: main                                                                *)
(* ============================================================================= *)

(* ============================================================================= *)
(* v3.0 Important Note: Python-Style Indentation                               *)
(* ============================================================================= *)
(* In v3.0, all block statements use Python-style indentation instead of       *)
(* explicit "end" keywords. The EBNF notation below uses "end" for structural  *)
(* clarity, but in actual syntax:                                              *)
(*   - "end <keyword>" is replaced by DEDENT token                             *)
(*   - Block bodies are marked by INDENT/DEDENT tokens from the lexer          *)
(*   - Indentation must be consistent (4 spaces or 1 tab = 4 spaces)           *)
(*                                                                              *)
(* Example:                                                                     *)
(*   EBNF:    while EXPR : STMTS end while                                     *)
(*   Actual:  while EXPR : INDENT STMTS DEDENT                                 *)
(* ============================================================================= *)

(* ============================================================================= *)
(* 1. Program Structure                                                         *)
(* ============================================================================= *)

program = { statement } ;

statement = variable_declaration
          | control_flow_statement
          | function_definition
          | return_statement
          | library_declaration
          | export_statement
          | import_statement
          | navigation_statement
          | action_statement
          | assertion_statement
          | exit_statement
          | service_call_statement
          | extraction_statement
          | log_statement
          | screenshot_statement
          | expression_statement
          ;

(* ============================================================================= *)
(* 2. Variable Declarations                                                     *)
(* ============================================================================= *)

variable_declaration = let_statement | const_statement | assignment ;

let_statement = "let" identifier "=" expression ;

const_statement = "const" identifier "=" expression ;

assignment = identifier "=" expression ;

identifier = IDENTIFIER ;

(* ============================================================================= *)
(* 3. Control Flow Statements                                                   *)
(* ============================================================================= *)

control_flow_statement = step_block
                       | if_block
                       | when_block
                       | for_each_loop
                       | while_loop
                       | break_statement
                       | continue_statement
                       ;

(* Step Block *)
step_block = "step" string_literal [ ":" ]
             [ "with" "diagnosis" diagnosis_level ]
             statement_list
             "end" "step" ;

diagnosis_level = "none" | "minimal" | "basic" | "standard" | "detailed" | "full" ;

(* If Block *)
if_block = "if" expression ":"
           statement_list
           [ else_clause ]
           "end" "if" ;

else_clause = "else" ":" statement_list ;

(* When Block *)
when_block = "when" string_literal ":"
             when_case_list
             [ otherwise_clause ]
             "end" "when" ;

when_case_list = when_case { when_case } ;

when_case = string_literal ":" statement_list ;

otherwise_clause = "otherwise" ":" statement_list ;

(* For Each Loop *)
for_each_loop = "for" identifier "in" expression ":"
                statement_list
                "end" "for" ;

(* While Loop - v3.0 *)
while_loop = "while" expression ":"
             statement_list
             "end" "while" ;

(* Break Statement - v3.0 *)
break_statement = "break" ;

(* Continue Statement - v3.0 *)
continue_statement = "continue" ;

statement_list = { statement } ;

(* ============================================================================= *)
(* 3.5. Function Definitions and Return Statements (v4.3)                      *)
(* ============================================================================= *)

(* Function Definition - v4.3 *)
function_definition = "function" identifier "(" [ parameter_list ] ")" ":"
                      statement_list
                      "end" "function" ;

parameter_list = identifier { "," identifier } ;

(* Return Statement - v4.3 *)
return_statement = "return" [ expression ] ;

(* Expression Statement - v4.3 (for standalone function calls) *)
expression_statement = function_call ;

(* Function Call Expression - v4.3 *)
function_call = identifier "(" [ argument_list ] ")" ;

argument_list = expression { "," expression } ;

(* Semantics:
   - Functions are user-defined, reusable code blocks
   - Parameters are pass-by-value (copied into function scope)
   - Functions have local scope, isolated from global variables
   - Functions can access global constants (read-only)
   - Functions can call other functions (user-defined or built-in)
   - Recursion is NOT supported (detected at runtime)
   - Closures are NOT supported (cannot access outer function locals)
   - return statement is optional; functions return None by default
   - return can only be used inside functions
*)

(* ============================================================================= *)
(* 3.6. Module System (v5.0)                                                   *)
(* ============================================================================= *)

(* Library Declaration - v5.0 *)
library_declaration = "library" identifier ;

(* Export Statement - v5.0 *)
export_statement = "export" ( const_statement | function_definition ) ;

(* Import Statement - v5.0 *)
import_statement = import_alias | from_import ;

(* Import with alias: import module_name from "path" *)
import_alias = "import" identifier "from" string_literal ;

(* From-import: from "path" import name1, name2, ... *)
from_import = "from" string_literal "import" import_list ;

import_list = identifier { "," identifier } ;

(* Semantics:
   - library declaration must be the first line of a .flow file
   - library creates a namespace for exported members
   - export makes constants or functions available to importers
   - import loads a library and binds it to an alias
   - from-import loads specific members from a library
   - import paths are relative to the importing file
   - imported modules are cached (loaded once per execution)
   - circular imports are detected and prevented
   - member access: module_alias.member_name
*)

(* ============================================================================= *)
(* 4. Navigation Statements                                                     *)
(* ============================================================================= *)

navigation_statement = navigate_statement
                     | go_statement
                     | reload_statement
                     ;

(* Navigate To *)
navigate_statement = "navigate" "to" expression
                     [ wait_for_clause ] ;

wait_for_clause = "wait" "for" page_state ;

page_state = "networkidle" | "domcontentloaded" | "load" ;

(* Go Back/Forward *)
go_statement = "go" direction ;

direction = "back" | "forward" ;

(* Reload *)
reload_statement = "reload" ;

(* ============================================================================= *)
(* 5. Wait Statements                                                           *)
(* ============================================================================= *)

wait_statement = wait_duration
               | wait_for_element
               | wait_for_navigation
               ;

(* Wait Duration - v6.0.2: æ”¯æŒæ•°å€¼è¡¨è¾¾å¼ *)
wait_duration = "wait" [ "for" ] expression [ time_unit ] ;

time_unit = "seconds" | "milliseconds" | "s" | "ms" ;

(* Semantics (v6.0.2):
   - Literal form (backward compatible): wait 2s, wait 500ms
   - Expression form (v6.0.2 new): wait delay_time s, wait (retry * 2) s
   - Time unit is REQUIRED when using expressions (to avoid ambiguity)
   - Expression must evaluate to numeric type (int or float)
   - Unit conversion: ms â†’ seconds / 1000, s â†’ seconds
*)

(* Wait For Element *)
wait_for_element = "wait" "for" "element" selector
                   [ "to" "be" element_state ]
                   [ timeout_clause ] ;

element_state = "visible" | "hidden" | "attached" | "detached" ;

timeout_clause = "timeout" expression ;

(* Wait For Navigation *)
wait_for_navigation = "wait" "for" "navigation"
                      [ "to" expression ]
                      [ "wait" "for" page_state ]
                      [ timeout_clause ] ;

(* ============================================================================= *)
(* 6. Selection Statements                                                      *)
(* ============================================================================= *)

selection_statement = select_element | select_option ;

(* Select Element *)
select_element = "select" selector
                 [ "where" where_clause_list ] ;

where_clause_list = where_condition { "and" where_condition } ;

where_condition = attribute_check | text_check | value_check ;

attribute_check = attribute_name comparison_operator expression ;

attribute_name = "text" | "value" | "class" | "id" | "name"
               | "href" | "src" | "alt" | "title"
               | IDENTIFIER ;

text_check = "text" comparison_operator expression ;

value_check = "value" comparison_operator expression ;

comparison_operator = "contains" | "equals" | "matches" ;

(* Select Option *)
select_option = "select" "option" expression "from" selector ;

(* ============================================================================= *)
(* 7. Action Statements                                                         *)
(* ============================================================================= *)

action_statement = type_action
                 | click_action
                 | hover_action
                 | clear_action
                 | press_action
                 | scroll_action
                 | check_action
                 | upload_action
                 ;

(* Type Action *)
type_action = "type" expression [ "into" selector ]
              [ typing_modifier ] ;

typing_modifier = "slowly" | "fast" ;

(* Click Action *)
click_action = click_type [ selector ] ;

click_type = "click" | "double" "click" | "right" "click" ;

(* Hover Action *)
hover_action = "hover" [ "over" ] selector ;

(* Clear Action *)
clear_action = "clear" [ selector ] ;

(* Press Action *)
press_action = "press" expression ;

(* Scroll Action *)
scroll_action = "scroll" scroll_target ;

scroll_target = "to" ( "top" | "bottom" )
              | "to" selector
              | expression (* pixels *)
              ;

(* Check/Uncheck Action *)
check_action = ( "check" | "uncheck" ) selector ;

(* Upload Action *)
upload_action = "upload" "file" expression [ "to" selector ] ;

(* ============================================================================= *)
(* 8. Assertion Statements                                                      *)
(* ============================================================================= *)

assertion_statement = "assert" assertion_type ;

assertion_type = expression_assertion    (* v2.0: General expression assertion *)
               | url_assertion           (* v1.0: Specific assertions *)
               | element_assertion
               | text_assertion
               | attribute_assertion
               ;

(* General Expression Assertion (v2.0, v4.3+) *)
expression_assertion = expression [ "," expression ] ;
(* Syntax: assert EXPR [, message_expr]
   Examples:
     assert x > 5
     assert user.age >= 18, "User must be adult"
     assert condition, error_msg  # v4.3: message can be expression
*)

(* URL Assertion *)
url_assertion = "url" url_check ;

url_check = ( "contains" | "equals" | "matches" ) expression ;

(* Element Assertion *)
element_assertion = selector element_check ;

element_check = "exists"
              | "visible"
              | "hidden"
              | "has" "text" expression
              | "has" "value" expression
              | "has" attribute_name expression
              ;

(* Text Assertion *)
text_assertion = "text" "of" selector text_check ;

(* Attribute Assertion *)
attribute_assertion = attribute_name "of" selector attribute_check ;

(* ============================================================================= *)
(* 8.5. Exit Statement (v4.1)                                                   *)
(* ============================================================================= *)

(* Exit Statement - Controlled Termination *)
exit_statement = "exit" [ exit_code ] [ "," exit_message ] ;

exit_code = INTEGER ;

exit_message = STRING ;

(* Exit semantics:
   - exit           -> code=0 (success), no message
   - exit 0         -> code=0 (success), no message
   - exit 1         -> code=1 (failure), no message
   - exit "msg"     -> code=1 (failure), message="msg"
   - exit 0, "msg"  -> code=0 (success), message="msg"
   - exit 1, "msg"  -> code=1 (failure), message="msg"
*)

(* ============================================================================= *)
(* 9. Service Call Statements                                                   *)
(* ============================================================================= *)

service_call_statement = "call" string_literal
                         [ parameter_list ]
                         [ "into" identifier ] ;

parameter_list = parameter { "," parameter } ;

parameter = identifier "=" expression ;

(* ============================================================================= *)
(* 10. Extraction Statements                                                    *)
(* ============================================================================= *)

extraction_statement = "extract" extraction_target "from" selector
                       [ extraction_options ]
                       "into" identifier ;

extraction_target = "text" | "value" | "attr" string_literal ;

extraction_options = "pattern" string_literal ;

(* ============================================================================= *)
(* 11. Log Statements (v4.3+: log levels)                                       *)
(* ============================================================================= *)

log_statement = "log" [ log_level ] expression ;

log_level = "debug" | "info" | "success" | "warning" | "error" ;

(* Syntax (v4.3+):
   log "message"                    # Default: info level
   log info "message"               # Explicit level
   log debug "debug info"           # Debug: ðŸ”
   log success "done"               # Success: âœ“
   log warning "careful"            # Warning: âš 
   log error "failed"               # Error: âœ—
   log success f"User {name} registered"  # Level + f-string
*)

(* ============================================================================= *)
(* 12. Screenshot Statements                                                    *)
(* ============================================================================= *)

screenshot_statement = "screenshot" [ screenshot_target ]
                       [ "as" string_literal ]
                       [ screenshot_options ] ;

screenshot_target = "of" selector ;

screenshot_options = "fullpage" ;

(* ============================================================================= *)
(* 13. Expressions                                                              *)
(* ============================================================================= *)

expression = logical_or_expression ;

(* Logical OR (lowest precedence) *)
logical_or_expression = logical_and_expression
                        { "or" logical_and_expression } ;

(* Logical AND *)
logical_and_expression = logical_not_expression
                         { "and" logical_not_expression } ;

(* Logical NOT *)
logical_not_expression = [ "not" ] comparison_expression ;

(* Comparison *)
comparison_expression = additive_expression
                        [ comparison_operator additive_expression ] ;

comparison_operator_expr = "==" | "!=" | ">" | "<" | ">=" | "<=" ;

(* Additive *)
additive_expression = multiplicative_expression
                      { additive_operator multiplicative_expression } ;

additive_operator = "+" | "-" ;

(* Multiplicative *)
multiplicative_expression = unary_expression
                            { multiplicative_operator unary_expression } ;

multiplicative_operator = "*" | "/" | "%" ;

(* Unary *)
unary_expression = [ unary_operator ] postfix_expression ;

unary_operator = "-" | "not" ;

(* Postfix (member access, array access, method call) *)
postfix_expression = primary_expression { postfix_operator } ;

postfix_operator = member_access
                 | array_access
                 | method_call
                 ;

member_access = "." identifier ;

array_access = "[" expression "]" ;

method_call = "(" [ argument_list ] ")" ;

argument_list = expression { "," expression } ;

(* Primary *)
primary_expression = literal
                   | lambda_expression
                   | input_expression
                   | function_call
                   | identifier
                   | system_variable
                   | array_literal
                   | object_literal
                   | parenthesized_expression
                   ;

parenthesized_expression = "(" expression ")" ;

(* Input Expression - v5.1 *)
input_expression = "input" "(" expression [ "," input_parameter_list ] ")" ;

input_parameter_list = input_parameter { "," input_parameter } ;

input_parameter = "default" "=" expression
                | "type" "=" input_type
                ;

input_type = "text" | "password" | "integer" | "float" ;

(* Semantics:
   - input() prompts user for console input (interactive mode)
   - First argument is the prompt message (string or expression)
   - default= parameter provides value when input is empty (CI/CD friendly)
   - type= parameter specifies input type and auto-converts:
     - text: default, returns string
     - password: no echo, returns string
     - integer: converts to int, raises error if invalid
     - float: converts to float, raises error if invalid
   - Returns the input value (or default) after type conversion
   - Non-interactive mode: always uses default value if provided
*)

(* ============================================================================= *)
(* 13.5. Lambda Expressions (v6.4)                                             *)
(* ============================================================================= *)

(* Lambda Expression - v6.4 *)
lambda_expression = lambda_parameters "=>" expression ;

lambda_parameters = identifier                              (* Single parameter: x => expr *)
                  | "(" ")"                                 (* No parameters: () => expr *)
                  | "(" parameter_list ")"                  (* Multiple parameters: (x, y) => expr *)
                  ;

parameter_list = identifier { "," identifier } ;

(* Semantics:
   - Lambda expressions create anonymous functions (closures)
   - Capture outer scope variables (full closure support)
   - Can be stored in variables: let fn = x => x * 2
   - Can be passed as arguments: array.map(x => x * 2)
   - Can be returned from functions
   - Expression body only (no statement blocks)
   - Examples:
     - x => x * 2                    # Single parameter
     - (x, y) => x + y               # Multiple parameters
     - () => 42                      # No parameters
     - x => x.name                   # Member access
     - x => x > 5                    # Boolean expression
*)

(* ============================================================================= *)
(* 13.6. Collection Methods and Utility Functions (v6.4, v6.5, v6.6)          *)
(* ============================================================================= *)

(* Method calls on collections and strings *)
collection_method = filter_method      (* v6.4 *)
                  | map_method         (* v6.4 *)
                  | reduce_method      (* v6.4 *)
                  | find_method        (* v6.4 *)
                  | findIndex_method   (* v6.4 *)
                  | some_method        (* v6.4 *)
                  | every_method       (* v6.4 *)
                  | sort_method        (* v6.5 *)
                  | reverse_method     (* v6.5 *)
                  | slice_method       (* v6.5 *)
                  | join_method        (* v6.5 *)
                  | unique_method      (* v6.5 *)
                  | length_method      (* v6.5 *)
                  | flatten_method     (* v6.6 *)
                  | chunk_method       (* v6.6 *)
                  | capitalize_method  (* v6.6 *)
                  | padStart_method    (* v6.6 *)
                  | padEnd_method      (* v6.6 *)
                  | repeat_method      (* v6.6 *)
                  | keys_method        (* v6.6 *)
                  | values_method      (* v6.6 *)
                  | entries_method     (* v6.6 *)
                  ;

(* Core Collection Methods (v6.4) *)
filter_method = expression "." "filter" "(" expression ")" ;
(* Syntax: array.filter(predicate)
   Returns: new array with elements matching predicate
   Example: [1, 2, 3, 4].filter(x => x > 2)  # [3, 4]
*)

map_method = expression "." "map" "(" expression ")" ;
(* Syntax: array.map(transform)
   Returns: new array with transformed elements
   Example: [1, 2, 3].map(x => x * 2)  # [2, 4, 6]
*)

reduce_method = expression "." "reduce" "(" expression "," expression ")" ;
(* Syntax: array.reduce(reducer, initial)
   Returns: accumulated value
   Example: [1, 2, 3].reduce((acc, x) => acc + x, 0)  # 6
*)

find_method = expression "." "find" "(" expression ")" ;
(* Syntax: array.find(predicate)
   Returns: first element matching predicate, or None
   Example: [1, 2, 3].find(x => x > 2)  # 3
*)

findIndex_method = expression "." "findIndex" "(" expression ")" ;
(* Syntax: array.findIndex(predicate)
   Returns: index of first match, or -1
   Example: [1, 2, 3].findIndex(x => x > 2)  # 2
*)

some_method = expression "." "some" "(" expression ")" ;
(* Syntax: array.some(predicate)
   Returns: true if any element matches predicate
   Example: [1, 2, 3].some(x => x > 2)  # True
*)

every_method = expression "." "every" "(" expression ")" ;
(* Syntax: array.every(predicate)
   Returns: true if all elements match predicate
   Example: [1, 2, 3].every(x => x > 0)  # True
*)

(* Extended Collection Methods (v6.5) *)
sort_method = expression "." "sort" "(" [ expression ] ")" ;
(* Syntax: array.sort([comparator])
   Returns: new sorted array (ascending by default)
   Examples:
     [3, 1, 2].sort()                    # [1, 2, 3]
     users.sort((a, b) => a.age - b.age) # Sort by age
*)

reverse_method = expression "." "reverse" "(" ")" ;
(* Syntax: array.reverse()
   Returns: new reversed array
   Example: [1, 2, 3].reverse()  # [3, 2, 1]
*)

slice_method = expression "." "slice" "(" expression [ "," expression ] ")" ;
(* Syntax: array.slice(start[, end])
   Returns: new array slice from start to end
   Example: [1, 2, 3, 4, 5].slice(1, 3)  # [2, 3]
*)

join_method = expression "." "join" "(" expression ")" ;
(* Syntax: array.join(separator)
   Returns: string with elements joined by separator
   Example: ["a", "b", "c"].join(", ")  # "a, b, c"
*)

unique_method = expression "." "unique" "(" ")" ;
(* Syntax: array.unique()
   Returns: new array with duplicates removed
   Example: [1, 2, 2, 3, 1].unique()  # [1, 2, 3]
*)

length_method = expression "." "length" "(" ")" ;
(* Syntax: array.length()
   Returns: number of elements in array
   Example: [1, 2, 3].length()  # 3
*)

(* String Utility Methods (v6.6) *)
capitalize_method = expression "." "capitalize" "(" ")" ;
(* Syntax: string.capitalize()
   Returns: string with first letter capitalized
   Example: "hello world".capitalize()  # "Hello world"
*)

padStart_method = expression "." "padStart" "(" expression "," expression ")" ;
(* Syntax: string.padStart(length, fillStr)
   Returns: left-padded string
   Example: "5".padStart(3, "0")  # "005"
*)

padEnd_method = expression "." "padEnd" "(" expression "," expression ")" ;
(* Syntax: string.padEnd(length, fillStr)
   Returns: right-padded string
   Example: "5".padEnd(3, "0")  # "500"
*)

repeat_method = expression "." "repeat" "(" expression ")" ;
(* Syntax: string.repeat(count)
   Returns: string repeated count times
   Example: "ha".repeat(3)  # "hahaha"
*)

(* Array Utility Methods (v6.6) *)
flatten_method = expression "." "flatten" "(" [ expression ] ")" ;
(* Syntax: array.flatten([depth])
   Returns: flattened array (default depth: 1)
   Examples:
     [[1, 2], [3, 4]].flatten()         # [1, 2, 3, 4]
     [1, [2, [3]]].flatten(2)           # [1, 2, 3]
*)

chunk_method = expression "." "chunk" "(" expression ")" ;
(* Syntax: array.chunk(size)
   Returns: array split into chunks of size
   Example: [1, 2, 3, 4, 5].chunk(2)  # [[1, 2], [3, 4], [5]]
*)

(* Dictionary Utility Methods (v6.6) *)
keys_method = expression "." "keys" "(" ")" ;
(* Syntax: dict.keys()
   Returns: array of dictionary keys
   Example: {a: 1, b: 2}.keys()  # ["a", "b"]
*)

values_method = expression "." "values" "(" ")" ;
(* Syntax: dict.values()
   Returns: array of dictionary values
   Example: {a: 1, b: 2}.values()  # [1, 2]
*)

entries_method = expression "." "entries" "(" ")" ;
(* Syntax: dict.entries()
   Returns: array of [key, value] pairs
   Example: {a: 1, b: 2}.entries()  # [["a", 1], ["b", 2]]
*)

(* Global Utility Functions (v6.6) *)
(* These are built-in functions, not methods *)

(* zip(*arrays) - Combine multiple arrays element-wise *)
(* Syntax: zip(arr1, arr2, ...)
   Returns: array of tuples combining elements at same index
   Example: zip([1, 2], ["a", "b"])  # [[1, "a"], [2, "b"]]
*)

(* sleep(seconds) - Pause execution *)
(* Syntax: sleep(seconds)
   Returns: None (blocks execution for specified duration)
   Example: sleep(2)  # Pause for 2 seconds
*)

(* ============================================================================= *)
(* 14. Literals                                                                 *)
(* ============================================================================= *)

literal = string_literal
        | number_literal
        | boolean_literal
        | null_literal
        ;

string_literal = STRING_TOKEN ;
(* Supports interpolation: "Hello {name}" *)

number_literal = NUMBER_TOKEN ;
(* Examples: 123, 123.45, -10, 0.5 *)

boolean_literal = "true" | "false" ;

null_literal = "null" ;

(* Array Literal *)
array_literal = "[" [ array_elements ] "]" ;

array_elements = expression { "," expression } ;

(* Object Literal *)
object_literal = "{" [ object_pairs ] "}" ;

object_pairs = object_pair { "," object_pair } ;

object_pair = ( identifier | string_literal ) ":" expression ;

(* ============================================================================= *)
(* 15. System Variables                                                         *)
(* ============================================================================= *)

system_variable = "$" system_variable_path ;

system_variable_path = namespace { "." identifier } ;

namespace = "context" | "page" | "browser" | "element" | "data" | "env" | "config" ;

(* Examples:
   $context.task_id
   $page.url
   $page.title
   $env.API_KEY
   $config.base_url
*)

(* ============================================================================= *)
(* 16. Selectors                                                                *)
(* ============================================================================= *)

selector = expression ;
(* Selectors are CSS selectors or XPath expressions expressed as strings
   Examples:
   "#username"
   ".btn-primary"
   "input[name='email']"
   "//div[@class='container']"
*)

(* ============================================================================= *)
(* 17. Lexical Tokens                                                           *)
(* ============================================================================= *)

(* Identifiers *)
IDENTIFIER = letter { letter | digit | "_" } ;

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
       | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
       | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

(* String Tokens *)
STRING_TOKEN = double_quoted_string | single_quoted_string ;

double_quoted_string = '"' { string_character | interpolation } '"' ;

single_quoted_string = "'" { string_character } "'" ;

string_character = ? any Unicode character except quote and backslash ?
                 | escape_sequence ;

escape_sequence = "\\" ( "n" | "t" | "r" | "\\" | '"' | "'" ) ;

interpolation = "{" expression "}" ;

(* Number Tokens *)
NUMBER_TOKEN = [ "-" ] integer_part [ "." fractional_part ] ;

integer_part = digit { digit } ;

fractional_part = digit { digit } ;

(* ============================================================================= *)
(* 18. Keywords (Reserved Words)                                                *)
(* ============================================================================= *)

(* Keywords are case-insensitive *)

keywords = "let" | "const" | "navigate" | "to" | "go" | "back" | "forward" | "reload"
         | "wait" | "for" | "function" | "return" | "until" | "element" | "navigation"
         | "select" | "where" | "and" | "or" | "not"
         | "type" | "click" | "double" | "right" | "hover" | "over" | "of"
         | "clear" | "press" | "scroll" | "check" | "uncheck" | "upload" | "file" | "from"
         | "call" | "into" | "with"
         | "extract" | "attr" | "pattern"
         | "log" | "debug" | "info" | "success" | "warning" | "error"
         | "each" | "in"
         | "true" | "false" | "null"
         | "assert" | "url" | "contains" | "equals" | "matches" | "exists" | "visible" | "hidden"
         | "text" | "value" | "has"
         | "diagnosis" | "none" | "minimal" | "basic" | "standard" | "detailed" | "full"
         | "screenshot" | "as" | "fullpage"
         | "step" | "end" | "if" | "else" | "when" | "otherwise"
         | "option" | "input" | "button" | "link" | "textarea" | "div" | "span"
         | "slowly" | "fast"
         | "networkidle" | "domcontentloaded" | "load"
         | "attached" | "detached"
         | "top" | "bottom"
         | "timeout" | "be" | "class" | "id" | "name" | "href" | "src" | "alt" | "title"
         ;

(* ============================================================================= *)
(* 19. Operators                                                                *)
(* ============================================================================= *)

(* Assignment *)
(* = *)

(* Arithmetic *)
(* + - * / % *)

(* Comparison *)
(* == != > < >= <= *)

(* Logical *)
(* and or not *)

(* Member Access *)
(* . *)

(* Array/Object Access *)
(* [ ] *)

(* Function Call *)
(* ( ) *)

(* ============================================================================= *)
(* 20. Comments                                                                 *)
(* ============================================================================= *)

comment = line_comment | block_comment ;

line_comment = "#" { ? any character except newline ? } newline ;

block_comment = '"""' { ? any character ? } '"""' ;

(* ============================================================================= *)
(* 21. Operator Precedence (from lowest to highest)                            *)
(* ============================================================================= *)

(*
Priority 1 (Lowest):  or
Priority 2:           and
Priority 3:           not
Priority 4:           == != > < >= <=
Priority 5:           + -
Priority 6:           * / %
Priority 7:           unary - unary not
Priority 8:           . [] ()
Priority 9 (Highest): literals, identifiers, system variables, grouping ()
*)

(* ============================================================================= *)
(* 22. Example Programs                                                         *)
(* ============================================================================= *)

(*
Example 1: Simple Variable Assignment
======================================
let name = "Alice"
let age = 30
log "Name: {name}, Age: {age}"
*)

(*
Example 2: Navigation and Selection
===================================
navigate to "https://example.com"
wait for element "#username"

select "#username"
type "user@test.com"

select "#password"
type "secret123"

click "#login-button"
*)

(*
Example 3: Conditional Logic
============================
let count = 0

if count > 0:
    log "Count is positive"
else:
    log "Count is zero or negative"
end if
*)

(*
Example 4: Service Call
=======================
call "http.post" with
    url="https://api.example.com/users",
    json={name: "Alice", email: "alice@test.com"},
    headers={"Authorization": "Bearer token"}
into response

log "Status: {response.status_code}"

if response.status_code == 200:
    log "Success: User ID is {response.data.id}"
end if
*)

(*
Example 5: Loop
===============
let items = [1, 2, 3, 4, 5]

for item in items:
    log "Item: {item}"
    let squared = item * item
    log "Squared: {squared}"
end for
*)

(*
Example 6: Extraction
====================
navigate to "https://example.com/profile"

extract text from ".username" into username
extract attr "href" from ".profile-link" into profile_url

log "Username: {username}"
log "Profile URL: {profile_url}"
*)

(*
Example 7: Step Block with Diagnosis
====================================
step "User Login" with diagnosis detailed:
    navigate to $config.base_url + "/login"

    select "#email"
    type $config.test_user.email

    select "#password"
    type $config.test_user.password

    click "#submit-button"

    wait for element ".dashboard"
    assert .dashboard exists
end step
*)

(*
Example 8: When Block (Pattern Matching)
========================================
let status = "pending"

when status:
    "success":
        log "Operation succeeded"
    "error":
        log "Operation failed"
    "pending":
        log "Operation is in progress"
    otherwise:
        log "Unknown status"
end when
*)

(*
Example 9: Assertion
====================
navigate to "https://example.com"

assert url contains "example.com"
assert "#header" exists
assert "#header" visible
assert text of ".welcome" equals "Welcome!"
assert value of "#username" contains "user"
*)

(*
Example 10: System Variables
============================
log "Task ID: {$context.task_id}"
log "Current URL: {$page.url}"
log "Page Title: {$page.title}"
log "API Key: {$env.API_KEY}"
log "Base URL: {$config.base_url}"
*)

(*
Example 11: User-Defined Functions (v4.3)
=========================================
# Simple function definition
function greet():
    log "Hello, World!"
end function

# Call the function
greet()

# Function with parameters
function add(a, b):
    return a + b
end function

let sum = add(10, 20)
log "Sum: {sum}"  # Output: Sum: 30

# Function with local variables
function calculate_area(width, height):
    let area = width * height
    return area
end function

let room_area = calculate_area(5, 4)
log "Room area: {room_area}"  # Output: Room area: 20
*)

(*
Example 12: Function Composition (v4.3)
======================================
# Define validation functions
function is_valid_email(email):
    return email contains "@" and email contains "."
end function

function is_strong_password(password):
    return len(password) >= 8
end function

# Compose functions
function validate_user(email, password):
    if not is_valid_email(email):
        return false
    end if
    
    if not is_strong_password(password):
        return false
    end if
    
    return true
end function

# Use the composed function
let valid = validate_user("user@example.com", "secret123")

if valid:
    log "User credentials are valid"
else:
    log "Invalid credentials"
end if
*)

(*
Example 13: Functions with Loops (v4.3)
======================================
function sum_array(numbers):
    let total = 0
    for num in numbers:
        total = total + num
    end for
    return total
end function

function find_max(numbers):
    let max = numbers[0]
    for num in numbers:
        if num > max:
            max = num
        end if
    end for
    return max
end function

let values = [10, 25, 7, 42, 15]
let sum = sum_array(values)
let max = find_max(values)

log "Sum: {sum}"    # Output: Sum: 99
log "Max: {max}"    # Output: Max: 42
*)

(*
Example 14: Module System (v5.0)
======================================
# File: libs/validators.flow
library validators

export const EMAIL_PATTERN = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"

export function validate_email(email):
    # Email validation logic
    if email contains "@" and email contains ".":
        return true
    end if
    return false
end function

export function validate_age(age):
    return age >= 18 and age <= 120
end function

# File: main.flow
import validators from "libs/validators.flow"

let email = "user@example.com"
if validators.validate_email(email):
    log "Valid email"
end if

# Or use from-import
from "libs/validators.flow" import validate_email, EMAIL_PATTERN

if validate_email(email):
    log "Pattern: {EMAIL_PATTERN}"
end if
*)

(*
Example 15: Input Expression (v5.1)
======================================
# Basic input
let name = input("Enter your name: ")
log "Hello, {name}!"

# Input with default value (CI/CD friendly)
let email = input("Email: ", default="test@example.com")

# Input with type conversion
let age = input("Age: ", type=integer)
let price = input("Price: ", type=float)

# Password input (no echo)
let password = input("Password: ", type=password)

# Combined parameters
let retry_count = input("Retry count: ", default="3", type=integer)

# Conditional input
if $env.INTERACTIVE == "true":
    let custom_url = input("Enter URL: ", default="https://example.com")
else:
    let custom_url = "https://example.com"
end if

# Input in loops
let num_items = input("How many items? ", type=integer)
for i in range(num_items):
    let item = input("Item {i + 1}: ")
    log "Added: {item}"
end for
*)

(*
Example 16: Lambda Expressions and Collection Methods (v6.4)
===========================================================
# Lambda expressions
let double = x => x * 2
let add = (x, y) => x + y

log "double(5): {double(5)}"       # 10
log "add(3, 7): {add(3, 7)}"       # 10

# filter() - Filter elements matching predicate
let numbers = [1, 2, 3, 4, 5, 6]
let evens = numbers.filter(x => x % 2 == 0)
log "Even numbers: {evens}"        # [2, 4, 6]

# map() - Transform each element
let doubled = numbers.map(x => x * 2)
log "Doubled: {doubled}"           # [2, 4, 6, 8, 10, 12]

# reduce() - Accumulate/aggregate values
let sum = numbers.reduce((acc, x) => acc + x, 0)
log "Sum: {sum}"                   # 21

# find() - Find first matching element
let found = numbers.find(x => x > 3)
log "First > 3: {found}"           # 4

# findIndex() - Find index of first match
let index = numbers.findIndex(x => x > 3)
log "Index of first > 3: {index}"  # 3

# some() - Check if any element matches
let hasLarge = numbers.some(x => x > 5)
log "Has number > 5: {hasLarge}"   # True

# every() - Check if all elements match
let allPositive = numbers.every(x => x > 0)
log "All positive: {allPositive}"  # True

# Method chaining
let result = numbers.filter(x => x > 2).map(x => x * 2).reduce((acc, x) => acc + x, 0)
log "Chained result: {result}"     # 28
*)

(*
Example 17: Extended Collection Methods (v6.5)
==============================================
# sort() - Sort array
let unsorted = [3, 1, 4, 1, 5, 9, 2, 6]
let sorted = unsorted.sort()
log "Sorted: {sorted}"             # [1, 1, 2, 3, 4, 5, 6, 9]

# sort with comparator
let users = [{name: "Bob", age: 30}, {name: "Alice", age: 25}]
let sortedByAge = users.sort((a, b) => a.age - b.age)
log "Sorted by age: {sortedByAge}"

# reverse() - Reverse array
let reversed = [1, 2, 3, 4, 5].reverse()
log "Reversed: {reversed}"         # [5, 4, 3, 2, 1]

# slice() - Extract array portion
let numbers = [1, 2, 3, 4, 5]
let slice1 = numbers.slice(1, 3)
log "Slice [1:3]: {slice1}"        # [2, 3]

# join() - Join array elements into string
let words = ["Hello", "Flowby", "DSL"]
let sentence = words.join(" ")
log "Joined: {sentence}"           # "Hello Flowby DSL"

# unique() - Remove duplicates
let duplicates = [1, 2, 2, 3, 1, 4, 3]
let unique = duplicates.unique()
log "Unique: {unique}"             # [1, 2, 3, 4]

# length() - Get array length
let count = [1, 2, 3, 4, 5].length()
log "Length: {count}"              # 5
*)

(*
Example 18: Utility Functions (v6.6)
====================================
# String methods
let title = "hello world"
let capitalized = title.capitalize()
log "Capitalized: {capitalized}"   # "Hello world"

let id = "5"
let paddedId = id.padStart(3, "0")
log "Padded ID: {paddedId}"        # "005"

let code = "A"
let paddedCode = code.padEnd(4, "0")
log "Padded code: {paddedCode}"    # "A000"

let pattern = "="
let line = pattern.repeat(40)
log line                           # "========================================"

# Array utility methods
let nested = [[1, 2], [3, 4], [5, 6]]
let flat = nested.flatten()
log "Flattened: {flat}"            # [1, 2, 3, 4, 5, 6]

let deepNested = [1, [2, [3, [4]]]]
let flat2 = deepNested.flatten(2)
log "Flatten(2): {flat2}"          # [1, 2, 3, [4]]

let numbers = [1, 2, 3, 4, 5, 6, 7]
let chunks = numbers.chunk(3)
log "Chunked: {chunks}"            # [[1, 2, 3], [4, 5, 6], [7]]

# Dictionary methods
let user = {name: "Alice", age: 30, city: "NYC"}
let keys = user.keys()
let values = user.values()
let entries = user.entries()
log "Keys: {keys}"                 # ["name", "age", "city"]
log "Values: {values}"             # ["Alice", 30, "NYC"]
log "Entries: {entries}"           # [["name", "Alice"], ["age", 30], ["city", "NYC"]]

# Global utility functions
let ids = [1, 2, 3]
let names = ["Alice", "Bob", "Charlie"]
let combined = zip(ids, names)
log "Zipped: {combined}"           # [[1, "Alice"], [2, "Bob"], [3, "Charlie"]]

log "Starting task..."
sleep(2)
log "Task completed after 2 seconds"
*)

(*
Example 19: Practical Use Cases (v6.6)
======================================
# Use case 1: Data transformation pipeline
let users = [{name: "alice", age: 25, active: True}, {name: "bob", age: 30, active: False}, {name: "charlie", age: 35, active: True}]

let activeUserNames = users.filter(u => u.active).map(u => u.name.capitalize()).join(", ")

log "Active users: {activeUserNames}"  # "Alice, Charlie"

# Use case 2: Statistical analysis
let scores = [85, 92, 78, 95, 88, 91]
let average = scores.reduce((acc, x) => acc + x, 0) / scores.length()
let passed = scores.filter(x => x >= 80).length()
let allPassed = scores.every(x => x >= 60)

log "Average: {average}"           # 88.17
log "Passed: {passed}/{scores.length()}"  # 5/6
log "All passed: {allPassed}"      # True

# Use case 3: Batch processing
let items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let batches = items.chunk(3)

for batch in batches:
    log "Processing batch: {batch}"
    sleep(0.5)
    log "Batch complete"
end for

# Use case 4: Data formatting
let headers = ["ID", "Name", "Score"]
let data = [[1, "Alice", 95], [2, "Bob", 88]]

let formatted = data.map(row => zip(headers, row).map(pair => f"{pair[0]}: {pair[1]}").join(", "))

for line in formatted:
    log line
end for
# Output:
# ID: 1, Name: Alice, Score: 95
# ID: 2, Name: Bob, Score: 88
*)

(* ============================================================================= *)
(* End of EBNF Grammar Specification                                           *)
(* ============================================================================= *)
