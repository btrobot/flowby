# VR-002 常量修改检查实现分析

## 📋 规则定义

**VR-002**: 常量不能重新赋值

**规范来源**: CLAUDE.md 第 360-363 行

```
- VR-001: 变量使用前必须声明
- VR-002: 常量不能重新赋值
- VR-003: 同一作用域不能重复声明
- VR-004: 系统变量（page, env）只读
```

---

## 🔍 当前实现状态

### 1. **双重实现系统**

项目中存在**两套独立的检查机制**，分别在不同阶段执行：

#### **机制 A：Parser 阶段（Violation 记录模式）**

**位置**: `src/flowby/parser.py:1725-1734`

```python
def _parse_assignment(self) -> Assignment:
    """解析赋值语句"""
    line = self._peek().line
    name_token = self._consume_identifier_or_keyword("期望变量名")
    self._consume(TokenType.EQUALS_SIGN, "期望 '='")
    value = self._parse_expression()

    # VR规则检查：检查是否为常量修改
    symbol = self.symbol_table_stack.current_scope()._lookup(name_token.value)
    if symbol and not symbol.is_mutable():
        type_name = "常量" if symbol.symbol_type == SymbolType.CONSTANT else "系统变量"
        self.violations.append(Violation(
            rule_id="VR-VAR-004",  # ⚠️ 注意：不是 VR-002！
            message=f"不能修改 {type_name}: '{name_token.value}'",
            line_number=line,
            severity="ERROR"
        ))

    return Assignment(name=name_token.value, value=value, line=line)
```

**特点**：
- ✅ Parser 阶段执行（早期检测）
- ⚠️ **不会阻止解析**：只记录违规，继续解析
- ⚠️ 规则ID 为 `VR-VAR-004`（而非 VR-002）
- 🔧 用于 Dry-Run 模式和 IDE 集成

#### **机制 B：Interpreter 阶段（运行时错误模式）**

**位置**: `src/flowby/symbol_table.py:255-295`

```python
def set(self, name: str, value: Any, line_number: int) -> None:
    """
    设置符号值（向上查找）

    Raises:
        RuntimeError: 如果符号未定义
        RuntimeError: 如果尝试修改常量或系统变量
    """
    # 向上查找符号
    symbol = self._lookup(name)

    if symbol is None:
        raise RuntimeError(
            f"未定义的变量: {name} (line {line_number})"
        )

    # 检查是否可修改
    if not symbol.is_mutable():
        raise RuntimeError(
            f"不能修改 {symbol.symbol_type.value}: {name} "
            f"(定义于 line {symbol.line_number}, 修改于 line {line_number})"
        )

    # 修改值
    symbol.value = value
```

**特点**：
- ✅ 运行时执行（最终防线）
- ✅ **立即抛出异常**：阻止执行继续
- ✅ 详细错误信息（包含定义行和修改行）
- 🎯 用于命令行执行模式

---

## 📊 VR 规则编号混乱问题

### 问题描述

文档和代码中存在**规则编号不一致**的情况：

| 文档位置 | 规则名称 | 规则ID | 说明 |
|---------|---------|--------|------|
| CLAUDE.md | VR-002 | - | 常量不能重新赋值 |
| CLAUDE.md | VR-004 | - | 系统变量只读 |
| parser.py | - | VR-VAR-004 | 常量/系统变量修改检查 |
| parser.py | - | VR-VAR-003 | 重复声明检查 |
| DRY_RUN_FEATURE.md | VR-VAR-002 | VR-VAR-002 | 常量重赋值 |
| DRY_RUN_FEATURE.md | VR-VAR-004 | VR-VAR-004 | 系统变量只读 |

**冲突点**：
- 📄 文档：VR-002（常量修改）和 VR-004（系统变量）是**两个独立规则**
- 💻 代码：`VR-VAR-004` **同时检查**常量和系统变量修改

---

## 🎯 设计哲学差异

### **旧系统（Violation 模式）**

**设计目标**: 收集所有错误，一次性报告

```python
# 示例：允许解析继续，收集所有错误
violations = [
    Violation("VR-VAR-003", "变量 'x' 重复声明", line=5),
    Violation("VR-VAR-004", "不能修改常量 'MAX'", line=10),
    Violation("VR-VAR-004", "不能修改系统变量 'page'", line=15),
]
# 然后一次性报告所有 3 个错误
```

**适用场景**：
- 🧪 Dry-Run 模式（`--dry-run`）
- 🛠️ IDE 集成（实时语法检查）
- 📝 Linter 工具（一次性报告所有问题）

**优点**：
- ✅ 用户体验好：一次看到所有错误
- ✅ 适合开发工具集成
- ✅ 支持警告/错误分级

**缺点**：
- ❌ 实现复杂：需要错误收集和延迟报告机制
- ❌ 维护成本高：每个规则需要双重实现
- ❌ 当前未完全实现：violations 记录后未被使用

### **新系统（VR-001 模式）**

**设计目标**: 发现错误立即停止

```python
# 示例：立即抛出异常，停止解析
if not self.symbol_table_stack.exists(var_name):
    raise ParserError(
        expr.line, 0, "IDENTIFIER", var_name,
        f"未定义的变量 '{var_name}'（VR-001 违规）",
        f"在使用前先用 'let' 或 'const' 声明变量"
    )
```

**适用场景**：
- 🖥️ 命令行执行（`flowby script.flow`）
- 🚀 CI/CD 流水线（快速失败）
- 🔒 严格模式（零容忍错误）

**优点**：
- ✅ 实现简单：直接抛出异常即可
- ✅ 性能好：发现错误立即停止
- ✅ 符合 Python 哲学（"显式优于隐式"）

**缺点**：
- ❌ 用户体验差：每次只能看到一个错误
- ❌ 开发效率低：需要多次运行才能修复所有错误

---

## 💡 VR-002 实现建议

基于当前 VR-001 的实现模式和项目状态（个人开发，无外部用户），我建议：

### **方案 A（推荐）：统一到 Parser 阶段 + 错误模式**

将 VR-002 改为与 VR-001 一致的实现方式：

#### 1. 修改 `_parse_assignment()` 方法

```python
def _parse_assignment(self) -> Assignment:
    """解析赋值语句"""
    line = self._peek().line
    name_token = self._consume_identifier_or_keyword("期望变量名")

    # v6.3: VR-002 检查 - 常量不能重新赋值
    symbol = self.symbol_table_stack.current_scope()._lookup(name_token.value)
    if symbol and symbol.symbol_type == SymbolType.CONSTANT:
        raise ParserError(
            line, 0, "IDENTIFIER", name_token.value,
            f"不能修改常量 '{name_token.value}'（VR-002 违规）",
            f"常量在定义后不可修改，请使用 'let' 声明可变变量"
        )

    # v6.3: VR-004 检查 - 系统变量只读
    if symbol and symbol.symbol_type == SymbolType.SYSTEM:
        raise ParserError(
            line, 0, "IDENTIFIER", name_token.value,
            f"不能修改系统变量 '{name_token.value}'（VR-004 违规）",
            f"系统变量 (page, env, response) 是只读的"
        )

    self._consume(TokenType.EQUALS_SIGN, "期望 '='")
    value = self._parse_expression()

    return Assignment(name=name_token.value, value=value, line=line)
```

#### 2. 移除旧的 Violation 记录代码

```python
# 删除以下代码（行 1725-1734）
# VR规则检查：检查是否为常量修改
symbol = self.symbol_table_stack.current_scope()._lookup(name_token.value)
if symbol and not symbol.is_mutable():
    type_name = "常量" if symbol.symbol_type == SymbolType.CONSTANT else "系统变量"
    self.violations.append(Violation(
        rule_id="VR-VAR-004",
        message=f"不能修改 {type_name}: '{name_token.value}'",
        line_number=line,
        severity="ERROR"
    ))
```

#### 3. 保留运行时检查作为最终防线

保留 `symbol_table.py` 中的运行时检查，作为防御性编程的一部分。

#### 4. 编写测试用例

```python
# tests/unit/dsl/test_vr002_const_reassignment.py

def test_const_reassignment_detected():
    """测试：修改常量应在 Parser 阶段报错"""
    source = """
const MAX = 100
MAX = 200
"""
    tokens = Lexer().tokenize(source)
    with pytest.raises(ParserError) as exc_info:
        Parser().parse(tokens)

    assert "不能修改常量" in str(exc_info.value)
    assert "MAX" in str(exc_info.value)
    assert "VR-002" in str(exc_info.value)

def test_system_variable_modification_detected():
    """测试：修改系统变量应在 Parser 阶段报错"""
    source = """
page = "invalid"
"""
    tokens = Lexer().tokenize(source)
    with pytest.raises(ParserError) as exc_info:
        Parser().parse(tokens)

    assert "不能修改系统变量" in str(exc_info.value)
    assert "page" in str(exc_info.value)
    assert "VR-004" in str(exc_info.value)
```

### **工作量估算**

| 任务 | 时间 | 说明 |
|------|------|------|
| 修改 `_parse_assignment()` | 30 分钟 | 拆分 VR-002 和 VR-004 检查 |
| 移除旧 Violation 代码 | 15 分钟 | 删除冗余代码 |
| 编写测试用例 | 1 小时 | 覆盖常量/系统变量修改场景 |
| 运行测试验证 | 15 分钟 | 确保无破坏性影响 |
| 更新文档 | 15 分钟 | CHANGELOG.md |
| **总计** | **2-2.5 小时** | **简单直接** |

---

### **方案 B（不推荐）：完善 Violation 系统**

如果要保留 Violation 系统，需要额外工作：

#### 1. 实现违规处理逻辑

```python
# 在 Parser.parse() 方法末尾
def parse(self, tokens: List[Token]) -> Program:
    # ... 现有解析逻辑 ...

    # 检查是否有违规
    if self.violations:
        error_violations = [v for v in self.violations if v.severity == "ERROR"]
        if error_violations:
            # 格式化所有错误信息
            errors = "\n".join([
                f"  - [{v.rule_id}] {v.message} (第 {v.line_number} 行)"
                for v in error_violations
            ])
            raise ParserError(
                error_violations[0].line_number, 0,
                "VALIDATION", "",
                f"发现 {len(error_violations)} 个语义错误",
                errors
            )

    return program
```

#### 2. 统一规则编号

- 修改 `VR-VAR-004` → 拆分为 `VR-VAR-002`（常量）和 `VR-VAR-004`（系统变量）
- 更新所有文档和代码中的规则引用

#### 3. 实现 Dry-Run 模式

```python
# CLI 参数处理
if args.dry_run:
    parser = Parser()
    ast = parser.parse(tokens)

    # 报告违规（包括警告）
    if parser.violations:
        print(f"发现 {len(parser.violations)} 个问题：")
        for v in parser.violations:
            print(f"  [{v.severity}] {v.rule_id}: {v.message} (行 {v.line_number})")

    # 只有 ERROR 才返回非零退出码
    error_count = sum(1 for v in parser.violations if v.severity == "ERROR")
    sys.exit(1 if error_count > 0 else 0)
```

#### 4. 工作量估算

| 任务 | 时间 | 说明 |
|------|------|------|
| 实现违规处理逻辑 | 1 小时 | 在 Parser 末尾检查并抛出异常 |
| 统一规则编号 | 1 小时 | 拆分 VR-VAR-004，更新所有引用 |
| 实现 Dry-Run 模式 | 2 小时 | CLI 参数处理和格式化输出 |
| 编写测试用例 | 2 小时 | Dry-Run 模式测试 |
| 运行测试验证 | 30 分钟 | 全量测试 |
| 更新文档 | 1 小时 | Dry-Run 使用文档 |
| **总计** | **7-8 小时** | **复杂但功能强大** |

**不推荐原因**：
- ❌ 工作量大（7-8 小时 vs 2-2.5 小时）
- ❌ 当前项目无 IDE 集成需求
- ❌ 个人开发项目，Dry-Run 模式价值有限
- ❌ 增加代码复杂度

---

## 🎯 最终推荐

**采用方案 A**：统一到 Parser 阶段 + 错误模式

**理由**：
1. ✅ **一致性**：与 VR-001 实现方式一致
2. ✅ **简单性**：工作量小（2-2.5 小时）
3. ✅ **高效性**：早期检测，快速失败
4. ✅ **符合现状**：个人开发，无 IDE 集成需求
5. ✅ **可维护性**：单一检查点，易于维护

**实施步骤**：
1. 修改 `_parse_assignment()` 方法（拆分 VR-002 和 VR-004）
2. 移除旧的 Violation 记录代码
3. 编写测试用例（10-15 个测试）
4. 运行完整测试套件验证
5. 更新 CHANGELOG.md
6. 提交代码

**预期结果**：
- ✅ VR-002 和 VR-004 在 Parser 阶段检测
- ✅ 立即抛出 ParserError，停止解析
- ✅ 清晰的错误消息和修复建议
- ✅ 与 VR-001 风格一致
- ✅ 完整测试覆盖

---

## 📝 附录：VR 规则完整清单

基于代码和文档的综合分析，建议的 VR 规则编号体系：

| 规则ID | 规则名称 | 实现状态 | 检查阶段 | 说明 |
|--------|---------|---------|---------|------|
| VR-001 | 变量使用前必须声明 | ✅ 已实现 | Parser | 直接抛出 ParserError |
| VR-002 | 常量不能重新赋值 | ⚠️ 部分实现 | Parser + Runtime | 建议改为 Parser 阶段直接抛出 |
| VR-003 | 同一作用域不能重复声明 | ⚠️ Violation 模式 | Parser | 建议改为直接抛出 ParserError |
| VR-004 | 系统变量只读 | ⚠️ 部分实现 | Parser + Runtime | 建议改为 Parser 阶段直接抛出 |

**建议行动**：
1. 立即实施 VR-002（本次任务）
2. 后续实施 VR-003（重复声明检查）
3. 最后清理 Violation 系统（如果不需要 Dry-Run 模式）

---

**报告生成时间**: 2025-12-01
**分析基于**: Flowby v6.3 (fix/parser-scope-management 分支)
